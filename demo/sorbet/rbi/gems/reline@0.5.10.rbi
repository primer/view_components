# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `reline` gem.
# Please instead update this file by running `bin/tapioca gem reline`.


# source://reline//lib/reline/version.rb#1
module Reline
  extend ::Forwardable
  extend ::SingleForwardable

  class << self
    # source://reline//lib/reline.rb#486
    def core; end

    # source://reline//lib/reline.rb#482
    def encoding_system_needs; end

    # source://reline//lib/reline.rb#463
    def insert_text(text); end

    # source://reline//lib/reline.rb#506
    def line_editor; end

    # source://reline//lib/reline.rb#502
    def ungetc(c); end
  end
end

# source://reline//lib/reline/io/ansi.rb#4
class Reline::ANSI < ::Reline::IO
  # @return [ANSI] a new instance of ANSI
  #
  # source://reline//lib/reline/io/ansi.rb#36
  def initialize; end

  # @return [Boolean]
  #
  # source://reline//lib/reline/io/ansi.rb#283
  def both_tty?; end

  # source://reline//lib/reline/io/ansi.rb#343
  def clear_screen; end

  # source://reline//lib/reline/io/ansi.rb#248
  def cursor_pos; end

  # source://reline//lib/reline/io/ansi.rb#366
  def deprep(otio); end

  # @return [Boolean]
  #
  # source://reline//lib/reline/io/ansi.rb#209
  def empty_buffer?; end

  # source://reline//lib/reline/io/ansi.rb#43
  def encoding; end

  # source://reline//lib/reline/io/ansi.rb#331
  def erase_after_cursor; end

  # source://reline//lib/reline/io/ansi.rb#231
  def get_screen_size; end

  # if the usage expects to wait indefinitely, use Float::INFINITY for timeout_second
  #
  # source://reline//lib/reline/io/ansi.rb#201
  def getc(timeout_second); end

  # source://reline//lib/reline/io/ansi.rb#307
  def hide_cursor; end

  # @return [Boolean]
  #
  # source://reline//lib/reline/io/ansi.rb#205
  def in_pasting?; end

  # source://reline//lib/reline/io/ansi.rb#170
  def inner_getc(timeout_second); end

  # source://reline//lib/reline/io/ansi.rb#154
  def input=(val); end

  # source://reline//lib/reline/io/ansi.rb#287
  def move_cursor_column(x); end

  # source://reline//lib/reline/io/ansi.rb#299
  def move_cursor_down(x); end

  # source://reline//lib/reline/io/ansi.rb#291
  def move_cursor_up(x); end

  # source://reline//lib/reline/io/ansi.rb#158
  def output=(val); end

  # source://reline//lib/reline/io/ansi.rb#359
  def prep; end

  # source://reline//lib/reline/io/ansi.rb#189
  def read_bracketed_paste; end

  # source://reline//lib/reline/io/ansi.rb#220
  def retrieve_keybuffer; end

  # This only works when the cursor is at the bottom of the scroll range
  # For more details, see https://github.com/ruby/reline/pull/577#issuecomment-1646679623
  #
  # source://reline//lib/reline/io/ansi.rb#337
  def scroll_down(x); end

  # source://reline//lib/reline/io/ansi.rb#70
  def set_bracketed_paste_key_bindings(config); end

  # source://reline//lib/reline/io/ansi.rb#47
  def set_default_key_bindings(config, allow_terminfo: T.unsafe(nil)); end

  # source://reline//lib/reline/io/ansi.rb#76
  def set_default_key_bindings_ansi_cursor(config); end

  # source://reline//lib/reline/io/ansi.rb#115
  def set_default_key_bindings_comprehensive_list(config); end

  # source://reline//lib/reline/io/ansi.rb#98
  def set_default_key_bindings_terminfo(config); end

  # source://reline//lib/reline/io/ansi.rb#241
  def set_screen_size(rows, columns); end

  # source://reline//lib/reline/io/ansi.rb#348
  def set_winch_handler(&handler); end

  # source://reline//lib/reline/io/ansi.rb#319
  def show_cursor; end

  # source://reline//lib/reline/io/ansi.rb#216
  def ungetc(c); end

  # source://reline//lib/reline/io/ansi.rb#162
  def with_raw_input; end
end

# source://reline//lib/reline/io/ansi.rb#17
Reline::ANSI::ANSI_CURSOR_KEY_BINDINGS = T.let(T.unsafe(nil), Hash)

# source://reline//lib/reline/io/ansi.rb#5
Reline::ANSI::CAPNAME_KEY_BINDINGS = T.let(T.unsafe(nil), Hash)

# source://reline//lib/reline/io/ansi.rb#188
Reline::ANSI::END_BRACKETED_PASTE = T.let(T.unsafe(nil), String)

# source://reline//lib/reline/io/ansi.rb#187
Reline::ANSI::START_BRACKETED_PASTE = T.let(T.unsafe(nil), String)

# source://reline//lib/reline/config.rb#1
class Reline::Config
  # @return [Config] a new instance of Config
  #
  # source://reline//lib/reline/config.rb#31
  def initialize; end

  # source://reline//lib/reline/config.rb#162
  def add_default_key_binding(keystroke, target); end

  # source://reline//lib/reline/config.rb#158
  def add_default_key_binding_by_keymap(keymap, keystroke, target); end

  # source://reline//lib/reline/config.rb#147
  def add_oneshot_key_binding(keystroke, target); end

  # Returns the value of attribute autocompletion.
  #
  # source://reline//lib/reline/config.rb#29
  def autocompletion; end

  # Sets the attribute autocompletion
  #
  # @param value the value to set the attribute autocompletion to.
  #
  # source://reline//lib/reline/config.rb#29
  def autocompletion=(_arg0); end

  # source://reline//lib/reline/config.rb#313
  def bind_key(key, func_name); end

  # source://reline//lib/reline/config.rb#246
  def bind_variable(name, value, raw_value); end

  # source://reline//lib/reline/config.rb#26
  def completion_ignore_case; end

  # source://reline//lib/reline/config.rb#26
  def completion_ignore_case=(_arg0); end

  # source://reline//lib/reline/config.rb#26
  def convert_meta; end

  # source://reline//lib/reline/config.rb#26
  def convert_meta=(_arg0); end

  # source://reline//lib/reline/config.rb#26
  def disable_completion; end

  # source://reline//lib/reline/config.rb#26
  def disable_completion=(_arg0); end

  # source://reline//lib/reline/config.rb#72
  def editing_mode; end

  # source://reline//lib/reline/config.rb#76
  def editing_mode=(val); end

  # @return [Boolean]
  #
  # source://reline//lib/reline/config.rb#80
  def editing_mode_is?(*val); end

  # source://reline//lib/reline/config.rb#26
  def emacs_mode_string; end

  # source://reline//lib/reline/config.rb#26
  def emacs_mode_string=(_arg0); end

  # source://reline//lib/reline/config.rb#26
  def enable_bracketed_paste; end

  # source://reline//lib/reline/config.rb#26
  def enable_bracketed_paste=(_arg0); end

  # source://reline//lib/reline/config.rb#211
  def handle_directive(directive, file, no, if_stack); end

  # source://reline//lib/reline/config.rb#26
  def history_size; end

  # source://reline//lib/reline/config.rb#26
  def history_size=(_arg0); end

  # source://reline//lib/reline/config.rb#92
  def inputrc_path; end

  # source://reline//lib/reline/config.rb#26
  def isearch_terminators; end

  # source://reline//lib/reline/config.rb#26
  def isearch_terminators=(_arg0); end

  # source://reline//lib/reline/config.rb#142
  def key_bindings; end

  # source://reline//lib/reline/config.rb#327
  def key_notation_to_code(notation); end

  # source://reline//lib/reline/config.rb#84
  def keymap; end

  # source://reline//lib/reline/config.rb#26
  def keyseq_timeout; end

  # source://reline//lib/reline/config.rb#26
  def keyseq_timeout=(_arg0); end

  # @return [Boolean]
  #
  # source://reline//lib/reline/config.rb#88
  def loaded?; end

  # source://reline//lib/reline/config.rb#361
  def parse_keyseq(str); end

  # source://reline//lib/reline/config.rb#122
  def read(file = T.unsafe(nil)); end

  # source://reline//lib/reline/config.rb#166
  def read_lines(lines, file = T.unsafe(nil)); end

  # source://reline//lib/reline/config.rb#369
  def reload; end

  # source://reline//lib/reline/config.rb#35
  def reset; end

  # source://reline//lib/reline/config.rb#154
  def reset_oneshot_key_bindings; end

  # source://reline//lib/reline/config.rb#42
  def reset_variables; end

  # source://reline//lib/reline/config.rb#308
  def retrieve_string(str); end

  # source://reline//lib/reline/config.rb#26
  def show_all_if_ambiguous; end

  # source://reline//lib/reline/config.rb#26
  def show_all_if_ambiguous=(_arg0); end

  # source://reline//lib/reline/config.rb#26
  def show_mode_in_prompt; end

  # source://reline//lib/reline/config.rb#26
  def show_mode_in_prompt=(_arg0); end

  # Returns the value of attribute test_mode.
  #
  # source://reline//lib/reline/config.rb#2
  def test_mode; end

  # source://reline//lib/reline/config.rb#26
  def vi_cmd_mode_string; end

  # source://reline//lib/reline/config.rb#26
  def vi_cmd_mode_string=(_arg0); end

  # source://reline//lib/reline/config.rb#26
  def vi_ins_mode_string; end

  # source://reline//lib/reline/config.rb#26
  def vi_ins_mode_string=(_arg0); end

  private

  # source://reline//lib/reline/config.rb#118
  def default_inputrc_path; end

  # @return [Boolean]
  #
  # source://reline//lib/reline/config.rb#374
  def seven_bit_encoding?(encoding); end
end

# source://reline//lib/reline/config.rb#6
class Reline::Config::InvalidInputrc < ::RuntimeError
  # Returns the value of attribute file.
  #
  # source://reline//lib/reline/config.rb#7
  def file; end

  # Sets the attribute file
  #
  # @param value the value to set the attribute file to.
  #
  # source://reline//lib/reline/config.rb#7
  def file=(_arg0); end

  # Returns the value of attribute lineno.
  #
  # source://reline//lib/reline/config.rb#7
  def lineno; end

  # Sets the attribute lineno
  #
  # @param value the value to set the attribute lineno to.
  #
  # source://reline//lib/reline/config.rb#7
  def lineno=(_arg0); end
end

# source://reline//lib/reline/config.rb#4
Reline::Config::KEYSEQ_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://reline//lib/reline/config.rb#10
Reline::Config::VARIABLE_NAMES = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline/config.rb#24
Reline::Config::VARIABLE_NAME_SYMBOLS = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline.rb#39
class Reline::Core
  extend ::Forwardable

  # @return [Core] a new instance of Core
  # @yield [_self]
  # @yieldparam _self [Reline::Core] the object that the method was called on
  #
  # source://reline//lib/reline.rb#67
  def initialize; end

  # @raise [ArgumentError]
  #
  # source://reline//lib/reline.rb#161
  def add_dialog_proc(name_sym, p, context = T.unsafe(nil)); end

  # source://reline//lib/reline.rb#409
  def ambiguous_width; end

  # source://reline//lib/reline.rb#54
  def auto_indent_proc; end

  # @raise [ArgumentError]
  #
  # source://reline//lib/reline.rb#146
  def auto_indent_proc=(p); end

  # source://reline//lib/reline.rb#54
  def basic_quote_characters; end

  # source://reline//lib/reline.rb#103
  def basic_quote_characters=(v); end

  # source://reline//lib/reline.rb#54
  def basic_word_break_characters; end

  # source://reline//lib/reline.rb#95
  def basic_word_break_characters=(v); end

  # source://reline//lib/reline.rb#54
  def completer_quote_characters; end

  # source://reline//lib/reline.rb#107
  def completer_quote_characters=(v); end

  # source://reline//lib/reline.rb#54
  def completer_word_break_characters; end

  # source://reline//lib/reline.rb#99
  def completer_word_break_characters=(v); end

  # source://reline//lib/reline.rb#54
  def completion_append_character; end

  # source://reline//lib/reline.rb#83
  def completion_append_character=(val); end

  # source://reline//lib/reline.rb#123
  def completion_case_fold; end

  # source://reline//lib/reline.rb#119
  def completion_case_fold=(v); end

  # source://reline//lib/reline.rb#54
  def completion_proc; end

  # @raise [ArgumentError]
  #
  # source://reline//lib/reline.rb#131
  def completion_proc=(p); end

  # source://reline//lib/reline.rb#127
  def completion_quote_character; end

  # Returns the value of attribute config.
  #
  # source://reline//lib/reline.rb#56
  def config; end

  # Sets the attribute config
  #
  # @param value the value to set the attribute config to.
  #
  # source://reline//lib/reline.rb#56
  def config=(_arg0); end

  # source://reline//lib/reline.rb#171
  def dialog_proc(name_sym); end

  # source://reline//lib/reline.rb#54
  def dig_perfect_match_proc; end

  # @raise [ArgumentError]
  #
  # source://reline//lib/reline.rb#155
  def dig_perfect_match_proc=(p); end

  # source://reline//lib/reline.rb#195
  def emacs_editing_mode; end

  # @return [Boolean]
  #
  # source://reline//lib/reline.rb#204
  def emacs_editing_mode?; end

  # source://reline//lib/reline.rb#79
  def encoding; end

  # source://reline//lib/reline.rb#54
  def filename_quote_characters; end

  # source://reline//lib/reline.rb#111
  def filename_quote_characters=(v); end

  # source://reline//lib/reline.rb#208
  def get_screen_size; end

  # @raise [TypeError]
  #
  # source://reline//lib/reline.rb#175
  def input=(val); end

  # source://reline//lib/reline.rb#75
  def io_gate; end

  # Returns the value of attribute key_stroke.
  #
  # source://reline//lib/reline.rb#57
  def key_stroke; end

  # Sets the attribute key_stroke
  #
  # @param value the value to set the attribute key_stroke to.
  #
  # source://reline//lib/reline.rb#57
  def key_stroke=(_arg0); end

  # Returns the value of attribute last_incremental_search.
  #
  # source://reline//lib/reline.rb#59
  def last_incremental_search; end

  # Sets the attribute last_incremental_search
  #
  # @param value the value to set the attribute last_incremental_search to.
  #
  # source://reline//lib/reline.rb#59
  def last_incremental_search=(_arg0); end

  # Returns the value of attribute line_editor.
  #
  # source://reline//lib/reline.rb#58
  def line_editor; end

  # Sets the attribute line_editor
  #
  # @param value the value to set the attribute line_editor to.
  #
  # source://reline//lib/reline.rb#58
  def line_editor=(_arg0); end

  # Returns the value of attribute output.
  #
  # source://reline//lib/reline.rb#60
  def output; end

  # @raise [TypeError]
  #
  # source://reline//lib/reline.rb#182
  def output=(val); end

  # source://reline//lib/reline.rb#54
  def output_modifier_proc; end

  # @raise [ArgumentError]
  #
  # source://reline//lib/reline.rb#136
  def output_modifier_proc=(p); end

  # source://reline//lib/reline.rb#54
  def pre_input_hook; end

  # source://reline//lib/reline.rb#151
  def pre_input_hook=(p); end

  # source://reline//lib/reline.rb#54
  def prompt_proc; end

  # @raise [ArgumentError]
  #
  # source://reline//lib/reline.rb#141
  def prompt_proc=(p); end

  # source://reline//lib/reline.rb#277
  def readline(prompt = T.unsafe(nil), add_hist = T.unsafe(nil)); end

  # source://reline//lib/reline.rb#251
  def readmultiline(prompt = T.unsafe(nil), add_hist = T.unsafe(nil), &confirm_multiline_termination); end

  # source://reline//lib/reline.rb#54
  def special_prefixes; end

  # source://reline//lib/reline.rb#115
  def special_prefixes=(v); end

  # source://reline//lib/reline.rb#190
  def vi_editing_mode; end

  # @return [Boolean]
  #
  # source://reline//lib/reline.rb#200
  def vi_editing_mode?; end

  private

  # source://reline//lib/reline.rb#294
  def inner_readline(prompt, add_hist, multiline, &confirm_multiline_termination); end

  # source://reline//lib/reline.rb#414
  def may_req_ambiguous_char_width; end

  # GNU Readline watis for "keyseq-timeout" milliseconds when the input is
  # ambiguous whether it is matching or matched.
  # If the next character does not arrive within the specified timeout, input
  # is considered as matched.
  # `ESC` is ambiguous because it can be a standalone ESC (matched) or part of
  # `ESC char` or part of CSI sequence (matching).
  #
  # source://reline//lib/reline.rb#379
  def read_io(keyseq_timeout, &block); end
end

# source://reline//lib/reline.rb#40
Reline::Core::ATTR_READER_NAMES = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline.rb#249
Reline::DEFAULT_DIALOG_CONTEXT = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline.rb#212
Reline::DEFAULT_DIALOG_PROC_AUTOCOMPLETE = T.let(T.unsafe(nil), Proc)

# source://reline//lib/reline/io/dumb.rb#3
class Reline::Dumb < ::Reline::IO
  # @return [Dumb] a new instance of Dumb
  #
  # source://reline//lib/reline/io/dumb.rb#6
  def initialize(encoding: T.unsafe(nil)); end

  # source://reline//lib/reline/io/dumb.rb#87
  def clear_screen; end

  # source://reline//lib/reline/io/dumb.rb#62
  def cursor_pos; end

  # source://reline//lib/reline/io/dumb.rb#104
  def deprep(otio); end

  # @return [Boolean]
  #
  # source://reline//lib/reline/io/dumb.rb#14
  def dumb?; end

  # source://reline//lib/reline/io/dumb.rb#18
  def encoding; end

  # source://reline//lib/reline/io/dumb.rb#81
  def erase_after_cursor; end

  # source://reline//lib/reline/io/dumb.rb#58
  def get_screen_size; end

  # source://reline//lib/reline/io/dumb.rb#39
  def getc(_timeout_second); end

  # source://reline//lib/reline/io/dumb.rb#66
  def hide_cursor; end

  # @return [Boolean]
  #
  # source://reline//lib/reline/io/dumb.rb#97
  def in_pasting?; end

  # source://reline//lib/reline/io/dumb.rb#31
  def input=(val); end

  # source://reline//lib/reline/io/dumb.rb#72
  def move_cursor_column(val); end

  # source://reline//lib/reline/io/dumb.rb#78
  def move_cursor_down(val); end

  # source://reline//lib/reline/io/dumb.rb#75
  def move_cursor_up(val); end

  # source://reline//lib/reline/io/dumb.rb#101
  def prep; end

  # source://reline//lib/reline/io/dumb.rb#84
  def scroll_down(val); end

  # source://reline//lib/reline/io/dumb.rb#28
  def set_default_key_bindings(_); end

  # source://reline//lib/reline/io/dumb.rb#90
  def set_screen_size(rows, columns); end

  # source://reline//lib/reline/io/dumb.rb#94
  def set_winch_handler(&handler); end

  # source://reline//lib/reline/io/dumb.rb#69
  def show_cursor; end

  # source://reline//lib/reline/io/dumb.rb#54
  def ungetc(c); end

  # source://reline//lib/reline/io/dumb.rb#35
  def with_raw_input; end
end

# Do not send color reset sequence
#
# source://reline//lib/reline/io/dumb.rb#4
Reline::Dumb::RESET_COLOR = T.let(T.unsafe(nil), String)

# NOTE: For making compatible with the rb-readline gem
#
# source://reline//lib/reline.rb#16
Reline::FILENAME_COMPLETION_PROC = T.let(T.unsafe(nil), T.untyped)

# source://reline//lib/reline/face.rb#3
class Reline::Face
  class << self
    # source://reline//lib/reline/face.rb#169
    def [](name); end

    # source://reline//lib/reline/face.rb#173
    def config(name, &block); end

    # source://reline//lib/reline/face.rb#178
    def configs; end

    # source://reline//lib/reline/face.rb#164
    def force_truecolor; end

    # source://reline//lib/reline/face.rb#182
    def load_initial_configs; end

    # source://reline//lib/reline/face.rb#195
    def reset_to_initial_configs; end

    # @return [Boolean]
    #
    # source://reline//lib/reline/face.rb#160
    def truecolor?; end
  end
end

# source://reline//lib/reline/face.rb#58
class Reline::Face::Config
  # @return [Config] a new instance of Config
  #
  # source://reline//lib/reline/face.rb#62
  def initialize(name, &block); end

  # source://reline//lib/reline/face.rb#84
  def [](name); end

  # source://reline//lib/reline/face.rb#72
  def define(name, **values); end

  # Returns the value of attribute definition.
  #
  # source://reline//lib/reline/face.rb#70
  def definition; end

  # source://reline//lib/reline/face.rb#77
  def reconfigure; end

  private

  # source://reline//lib/reline/face.rb#126
  def format_to_sgr(ordered_values); end

  # @return [Boolean]
  #
  # source://reline//lib/reline/face.rb#153
  def rgb_expression?(color); end

  # source://reline//lib/reline/face.rb#90
  def sgr_rgb(key, value); end

  # source://reline//lib/reline/face.rb#108
  def sgr_rgb_256color(key, value); end

  # source://reline//lib/reline/face.rb#99
  def sgr_rgb_truecolor(key, value); end
end

# source://reline//lib/reline/face.rb#59
Reline::Face::Config::ESSENTIAL_DEFINE_NAMES = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline/face.rb#60
Reline::Face::Config::RESET_SGR = T.let(T.unsafe(nil), String)

# source://reline//lib/reline/face.rb#4
Reline::Face::SGR_PARAMETERS = T.let(T.unsafe(nil), Hash)

# source://reline//lib/reline.rb#519
Reline::HISTORY = T.let(T.unsafe(nil), Reline::History)

# source://reline//lib/reline/history.rb#1
class Reline::History < ::Array
  # @return [History] a new instance of History
  #
  # source://reline//lib/reline/history.rb#2
  def initialize(config); end

  # source://reline//lib/reline/history.rb#52
  def <<(val); end

  # source://reline//lib/reline/history.rb#15
  def [](index); end

  # source://reline//lib/reline/history.rb#20
  def []=(index, val); end

  # source://reline//lib/reline/history.rb#25
  def concat(*val); end

  # source://reline//lib/reline/history.rb#10
  def delete_at(index); end

  # source://reline//lib/reline/history.rb#31
  def push(*val); end

  # source://reline//lib/reline/history.rb#6
  def to_s; end

  private

  # @raise [IndexError]
  #
  # source://reline//lib/reline/history.rb#62
  def check_index(index); end
end

# source://reline//lib/reline/io.rb#3
class Reline::IO
  # @return [Boolean]
  #
  # source://reline//lib/reline/io.rb#27
  def dumb?; end

  # source://reline//lib/reline/io.rb#35
  def reset_color_sequence; end

  # @return [Boolean]
  #
  # source://reline//lib/reline/io.rb#31
  def win?; end

  class << self
    # source://reline//lib/reline/io.rb#6
    def decide_io_gate; end
  end
end

# source://reline//lib/reline/io.rb#4
Reline::IO::RESET_COLOR = T.let(T.unsafe(nil), String)

# source://reline//lib/reline.rb#512
Reline::IOGate = T.let(T.unsafe(nil), Reline::ANSI)

# source://reline//lib/reline.rb#21
class Reline::Key < ::Struct
  # Returns the value of attribute char
  #
  # @return [Object] the current value of char
  def char; end

  # Sets the attribute char
  #
  # @param value [Object] the value to set the attribute char to.
  # @return [Object] the newly set value
  def char=(_); end

  # Returns the value of attribute combined_char
  #
  # @return [Object] the current value of combined_char
  def combined_char; end

  # Sets the attribute combined_char
  #
  # @param value [Object] the value to set the attribute combined_char to.
  # @return [Object] the newly set value
  def combined_char=(_); end

  # For dialog_proc `key.match?(dialog.name)`
  #
  # @return [Boolean]
  #
  # source://reline//lib/reline.rb#23
  def match?(sym); end

  # Returns the value of attribute with_meta
  #
  # @return [Object] the current value of with_meta
  def with_meta; end

  # Sets the attribute with_meta
  #
  # @param value [Object] the value to set the attribute with_meta to.
  # @return [Object] the newly set value
  def with_meta=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://reline//lib/reline/key_actor/base.rb#1
class Reline::KeyActor::Base
  # @return [Base] a new instance of Base
  #
  # source://reline//lib/reline/key_actor/base.rb#2
  def initialize(mapping = T.unsafe(nil)); end

  # source://reline//lib/reline/key_actor/base.rb#12
  def add(key, func); end

  # source://reline//lib/reline/key_actor/base.rb#27
  def clear; end

  # source://reline//lib/reline/key_actor/base.rb#23
  def get(key); end

  # source://reline//lib/reline/key_actor/base.rb#8
  def get_method(key); end

  # @return [Boolean]
  #
  # source://reline//lib/reline/key_actor/base.rb#19
  def matching?(key); end
end

# source://reline//lib/reline/key_actor/composite.rb#1
class Reline::KeyActor::Composite
  # @return [Composite] a new instance of Composite
  #
  # source://reline//lib/reline/key_actor/composite.rb#2
  def initialize(key_actors); end

  # source://reline//lib/reline/key_actor/composite.rb#10
  def get(key); end

  # @return [Boolean]
  #
  # source://reline//lib/reline/key_actor/composite.rb#6
  def matching?(key); end
end

# source://reline//lib/reline/key_actor/emacs.rb#2
Reline::KeyActor::EMACS_MAPPING = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline/key_actor/vi_command.rb#2
Reline::KeyActor::VI_COMMAND_MAPPING = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline/key_actor/vi_insert.rb#2
Reline::KeyActor::VI_INSERT_MAPPING = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline/key_stroke.rb#1
class Reline::KeyStroke
  # @return [KeyStroke] a new instance of KeyStroke
  #
  # source://reline//lib/reline/key_stroke.rb#6
  def initialize(config); end

  # source://reline//lib/reline/key_stroke.rb#42
  def expand(input); end

  # source://reline//lib/reline/key_stroke.rb#19
  def match_status(input); end

  private

  # source://reline//lib/reline/key_stroke.rb#106
  def key_mapping; end

  # returns match status of CSI/SS3 sequence and matched length
  #
  # source://reline//lib/reline/key_stroke.rb#70
  def match_unknown_escape_sequence(input, vi_mode: T.unsafe(nil)); end
end

# source://reline//lib/reline/key_stroke.rb#4
Reline::KeyStroke::CSI_INTERMEDIATE_BYTES_RANGE = T.let(T.unsafe(nil), Range)

# source://reline//lib/reline/key_stroke.rb#3
Reline::KeyStroke::CSI_PARAMETER_BYTES_RANGE = T.let(T.unsafe(nil), Range)

# source://reline//lib/reline/key_stroke.rb#2
Reline::KeyStroke::ESC_BYTE = T.let(T.unsafe(nil), Integer)

# Input partially matches to a key sequence
#
# source://reline//lib/reline/key_stroke.rb#13
Reline::KeyStroke::MATCHED = T.let(T.unsafe(nil), Symbol)

# Input exactly matches to a key sequence
#
# source://reline//lib/reline/key_stroke.rb#11
Reline::KeyStroke::MATCHING = T.let(T.unsafe(nil), Symbol)

# Input matches to a key sequence and the key sequence is a prefix of another key sequence
#
# source://reline//lib/reline/key_stroke.rb#15
Reline::KeyStroke::MATCHING_MATCHED = T.let(T.unsafe(nil), Symbol)

# Input does not match to any key sequence
#
# source://reline//lib/reline/key_stroke.rb#17
Reline::KeyStroke::UNMATCHED = T.let(T.unsafe(nil), Symbol)

# source://reline//lib/reline/kill_ring.rb#1
class Reline::KillRing
  include ::Enumerable

  # @return [KillRing] a new instance of KillRing
  #
  # source://reline//lib/reline/kill_ring.rb#61
  def initialize(max = T.unsafe(nil)); end

  # source://reline//lib/reline/kill_ring.rb#68
  def append(string, before_p = T.unsafe(nil)); end

  # source://reline//lib/reline/kill_ring.rb#116
  def each; end

  # source://reline//lib/reline/kill_ring.rb#83
  def process; end

  # source://reline//lib/reline/kill_ring.rb#96
  def yank; end

  # source://reline//lib/reline/kill_ring.rb#106
  def yank_pop; end
end

# source://reline//lib/reline/kill_ring.rb#21
class Reline::KillRing::RingBuffer
  # @return [RingBuffer] a new instance of RingBuffer
  #
  # source://reline//lib/reline/kill_ring.rb#25
  def initialize(max = T.unsafe(nil)); end

  # source://reline//lib/reline/kill_ring.rb#31
  def <<(point); end

  # @return [Boolean]
  #
  # source://reline//lib/reline/kill_ring.rb#56
  def empty?; end

  # Returns the value of attribute head.
  #
  # source://reline//lib/reline/kill_ring.rb#23
  def head; end

  # Returns the value of attribute size.
  #
  # source://reline//lib/reline/kill_ring.rb#22
  def size; end
end

# source://reline//lib/reline/kill_ring.rb#11
class Reline::KillRing::RingPoint < ::Struct
  # @return [RingPoint] a new instance of RingPoint
  #
  # source://reline//lib/reline/kill_ring.rb#12
  def initialize(str); end

  # source://reline//lib/reline/kill_ring.rb#16
  def ==(other); end
end

# source://reline//lib/reline/kill_ring.rb#6
Reline::KillRing::State::CONTINUED = T.let(T.unsafe(nil), Symbol)

# source://reline//lib/reline/kill_ring.rb#5
Reline::KillRing::State::FRESH = T.let(T.unsafe(nil), Symbol)

# source://reline//lib/reline/kill_ring.rb#7
Reline::KillRing::State::PROCESSED = T.let(T.unsafe(nil), Symbol)

# source://reline//lib/reline/kill_ring.rb#8
Reline::KillRing::State::YANK = T.let(T.unsafe(nil), Symbol)

# source://reline//lib/reline/line_editor.rb#6
class Reline::LineEditor
  # @return [LineEditor] a new instance of LineEditor
  #
  # source://reline//lib/reline/line_editor.rb#75
  def initialize(config, encoding); end

  # source://reline//lib/reline/line_editor.rb#681
  def add_dialog_proc(name, p, context = T.unsafe(nil)); end

  # Returns the value of attribute auto_indent_proc.
  #
  # source://reline//lib/reline/line_editor.rb#14
  def auto_indent_proc; end

  # Sets the attribute auto_indent_proc
  #
  # @param value the value to set the attribute auto_indent_proc to.
  #
  # source://reline//lib/reline/line_editor.rb#14
  def auto_indent_proc=(_arg0); end

  # TODO: Use "private alias_method" idiom after drop Ruby 2.5.
  #
  # source://reline//lib/reline/line_editor.rb#8
  def byte_pointer; end

  # source://reline//lib/reline/line_editor.rb#1380
  def byte_pointer=(val); end

  # source://reline//lib/reline/line_editor.rb#398
  def calculate_overlay_levels(overlay_levels); end

  # source://reline//lib/reline/line_editor.rb#1165
  def call_completion_proc; end

  # source://reline//lib/reline/line_editor.rb#1173
  def call_completion_proc_with_checking_args(pre, target, post); end

  # source://reline//lib/reline/line_editor.rb#446
  def clear_dialogs; end

  # Returns the value of attribute completion_append_character.
  #
  # source://reline//lib/reline/line_editor.rb#11
  def completion_append_character; end

  # Sets the attribute completion_append_character
  #
  # @param value the value to set the attribute completion_append_character to.
  #
  # source://reline//lib/reline/line_editor.rb#11
  def completion_append_character=(_arg0); end

  # Returns the value of attribute completion_proc.
  #
  # source://reline//lib/reline/line_editor.rb#10
  def completion_proc; end

  # Sets the attribute completion_proc
  #
  # @param value the value to set the attribute completion_proc to.
  #
  # source://reline//lib/reline/line_editor.rb#10
  def completion_proc=(_arg0); end

  # source://reline//lib/reline/line_editor.rb#1319
  def confirm_multiline_termination; end

  # Returns the value of attribute confirm_multiline_termination_proc.
  #
  # source://reline//lib/reline/line_editor.rb#9
  def confirm_multiline_termination_proc; end

  # Sets the attribute confirm_multiline_termination_proc
  #
  # @param value the value to set the attribute confirm_multiline_termination_proc to.
  #
  # source://reline//lib/reline/line_editor.rb#9
  def confirm_multiline_termination_proc=(_arg0); end

  # source://reline//lib/reline/line_editor.rb#304
  def current_byte_pointer_cursor; end

  # source://reline//lib/reline/line_editor.rb#1216
  def current_line; end

  # source://reline//lib/reline/line_editor.rb#1346
  def delete_text(start = T.unsafe(nil), length = T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#888
  def dialog_proc_scope_completion_journey_data; end

  # Returns the value of attribute dig_perfect_match_proc.
  #
  # source://reline//lib/reline/line_editor.rb#15
  def dig_perfect_match_proc; end

  # Sets the attribute dig_perfect_match_proc
  #
  # @param value the value to set the attribute dig_perfect_match_proc to.
  #
  # source://reline//lib/reline/line_editor.rb#15
  def dig_perfect_match_proc=(_arg0); end

  # source://reline//lib/reline/line_editor.rb#790
  def editing_mode; end

  # @return [Boolean]
  #
  # source://reline//lib/reline/line_editor.rb#218
  def eof?; end

  # source://reline//lib/reline/line_editor.rb#214
  def finalize; end

  # source://reline//lib/reline/line_editor.rb#1400
  def finish; end

  # @return [Boolean]
  #
  # source://reline//lib/reline/line_editor.rb#1396
  def finished?; end

  # source://reline//lib/reline/line_editor.rb#166
  def handle_signal; end

  # source://reline//lib/reline/line_editor.rb#1086
  def input_key(key); end

  # source://reline//lib/reline/line_editor.rb#1324
  def insert_multiline_text(text); end

  # source://reline//lib/reline/line_editor.rb#1336
  def insert_text(text); end

  # source://reline//lib/reline/line_editor.rb#82
  def io_gate; end

  # source://reline//lib/reline/line_editor.rb#1212
  def line; end

  # source://reline//lib/reline/line_editor.rb#351
  def modified_lines; end

  # source://reline//lib/reline/line_editor.rb#273
  def multiline_off; end

  # source://reline//lib/reline/line_editor.rb#269
  def multiline_on; end

  # Sets the attribute output
  #
  # @param value the value to set the attribute output to.
  #
  # source://reline//lib/reline/line_editor.rb#16
  def output=(_arg0); end

  # Returns the value of attribute output_modifier_proc.
  #
  # source://reline//lib/reline/line_editor.rb#12
  def output_modifier_proc; end

  # Sets the attribute output_modifier_proc
  #
  # @param value the value to set the attribute output_modifier_proc to.
  #
  # source://reline//lib/reline/line_editor.rb#12
  def output_modifier_proc=(_arg0); end

  # source://reline//lib/reline/line_editor.rb#471
  def print_nomultiline_prompt; end

  # source://reline//lib/reline/line_editor.rb#357
  def prompt_list; end

  # Returns the value of attribute prompt_proc.
  #
  # source://reline//lib/reline/line_editor.rb#13
  def prompt_proc; end

  # Sets the attribute prompt_proc
  #
  # @param value the value to set the attribute prompt_proc to.
  #
  # source://reline//lib/reline/line_editor.rb#13
  def prompt_proc=(_arg0); end

  # source://reline//lib/reline/line_editor.rb#1136
  def push_input_lines; end

  # source://reline//lib/reline/line_editor.rb#476
  def render; end

  # source://reline//lib/reline/line_editor.rb#461
  def render_finished; end

  # source://reline//lib/reline/line_editor.rb#406
  def render_line_differential(old_items, new_items); end

  # source://reline//lib/reline/line_editor.rb#554
  def rerender; end

  # source://reline//lib/reline/line_editor.rb#139
  def reset(prompt = T.unsafe(nil), encoding:); end

  # source://reline//lib/reline/line_editor.rb#260
  def reset_line; end

  # source://reline//lib/reline/line_editor.rb#222
  def reset_variables(prompt = T.unsafe(nil), encoding:); end

  # source://reline//lib/reline/line_editor.rb#550
  def rest_height(wrapped_cursor_y); end

  # source://reline//lib/reline/line_editor.rb#1243
  def retrieve_completion_block(set_completion_quote_character = T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1132
  def save_old_buffer; end

  # source://reline//lib/reline/line_editor.rb#363
  def screen_height; end

  # source://reline//lib/reline/line_editor.rb#371
  def screen_scroll_top; end

  # source://reline//lib/reline/line_editor.rb#367
  def screen_width; end

  # source://reline//lib/reline/line_editor.rb#1155
  def scroll_into_view; end

  # source://reline//lib/reline/line_editor.rb#1220
  def set_current_line(line, byte_pointer = T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1231
  def set_current_lines(lines, byte_pointer = T.unsafe(nil), line_index = T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#86
  def set_pasting_state(in_pasting); end

  # source://reline//lib/reline/line_editor.rb#205
  def set_signal_handlers; end

  # source://reline//lib/reline/line_editor.rb#1148
  def trim_input_lines; end

  # source://reline//lib/reline/line_editor.rb#1076
  def update(key); end

  # source://reline//lib/reline/line_editor.rb#453
  def update_dialogs(key = T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#546
  def upper_space_height(wrapped_cursor_y); end

  # source://reline//lib/reline/line_editor.rb#1388
  def whole_buffer; end

  # source://reline//lib/reline/line_editor.rb#1384
  def whole_lines; end

  # source://reline//lib/reline/line_editor.rb#343
  def with_cache(key, *deps); end

  # source://reline//lib/reline/line_editor.rb#962
  def wrap_method_call(method_symbol, method_obj, key, with_operator = T.unsafe(nil)); end

  # Calculate cursor position in word wrapped content.
  #
  # source://reline//lib/reline/line_editor.rb#437
  def wrapped_cursor_position; end

  # source://reline//lib/reline/line_editor.rb#375
  def wrapped_prompt_and_input_lines; end

  private

  # @return [Boolean]
  #
  # source://reline//lib/reline/line_editor.rb#952
  def argumentable?(method_obj); end

  # source://reline//lib/reline/line_editor.rb#1555
  def backward_char(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1858
  def backward_delete_char(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2000
  def backward_kill_word(key); end

  # source://reline//lib/reline/line_editor.rb#1982
  def backward_word(key); end

  # source://reline//lib/reline/line_editor.rb#1572
  def beginning_of_line(key); end

  # @return [Boolean]
  #
  # source://reline//lib/reline/line_editor.rb#1392
  def buffer_empty?; end

  # source://reline//lib/reline/line_editor.rb#1411
  def byteinsert(str, byte_pointer, other); end

  # source://reline//lib/reline/line_editor.rb#1405
  def byteslice!(str, byte_pointer, size); end

  # source://reline//lib/reline/line_editor.rb#308
  def calculate_nearest_cursor(cursor); end

  # source://reline//lib/reline/line_editor.rb#1418
  def calculate_width(str, allow_escape_code = T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2040
  def capitalize_word(key); end

  # source://reline//lib/reline/line_editor.rb#93
  def check_mode_string; end

  # source://reline//lib/reline/line_editor.rb#107
  def check_multiline_prompt(buffer, mode_string); end

  # source://reline//lib/reline/line_editor.rb#982
  def cleanup_waiting; end

  # source://reline//lib/reline/line_editor.rb#541
  def clear_rendered_screen_cache; end

  # source://reline//lib/reline/line_editor.rb#1966
  def clear_screen(key); end

  # source://reline//lib/reline/line_editor.rb#1438
  def complete(_key); end

  # source://reline//lib/reline/line_editor.rb#798
  def complete_internal_proc(list, is_menu); end

  # source://reline//lib/reline/line_editor.rb#1455
  def completion_journey_move(direction); end

  # source://reline//lib/reline/line_editor.rb#1471
  def completion_journey_up(_key); end

  # source://reline//lib/reline/line_editor.rb#2086
  def copy_for_vi(text); end

  # source://reline//lib/reline/line_editor.rb#1923
  def delete_char(key); end

  # source://reline//lib/reline/line_editor.rb#1938
  def delete_char_or_list(key); end

  # source://reline//lib/reline/line_editor.rb#692
  def dialog_range(dialog, dialog_y); end

  # source://reline//lib/reline/line_editor.rb#2050
  def downcase_word(key); end

  # source://reline//lib/reline/line_editor.rb#2339
  def ed_argument_digit(key); end

  # source://reline//lib/reline/line_editor.rb#1966
  def ed_clear_screen(key); end

  # source://reline//lib/reline/line_editor.rb#2285
  def ed_delete_next_char(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2197
  def ed_delete_prev_char(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2000
  def ed_delete_prev_word(key); end

  # Editline:: +ed-insert+ (vi input: almost all; emacs: printable characters)
  #            In insert mode, insert the input character left of the cursor
  #            position. In replace mode, overwrite the character at the
  #            cursor and move the cursor to the right by one character
  #            position. Accept an argument to do this repeatedly. It is an
  #            error if the input character is the NUL character (+Ctrl-@+).
  #            Failure to enlarge the edit buffer also results in an error.
  # Editline:: +ed-digit+ (emacs: 0 to 9) If in argument input mode, append
  #            the input digit to the argument being read. Otherwise, call
  #            +ed-insert+. It is an error if the input character is not a
  #            digit or if the existing argument is already greater than a
  #            million.
  # GNU Readline:: +self-insert+ (a, b, A, 1, !, …) Insert yourself.
  #
  # source://reline//lib/reline/line_editor.rb#1498
  def ed_digit(key); end

  # Editline:: +ed-insert+ (vi input: almost all; emacs: printable characters)
  #            In insert mode, insert the input character left of the cursor
  #            position. In replace mode, overwrite the character at the
  #            cursor and move the cursor to the right by one character
  #            position. Accept an argument to do this repeatedly. It is an
  #            error if the input character is the NUL character (+Ctrl-@+).
  #            Failure to enlarge the edit buffer also results in an error.
  # Editline:: +ed-digit+ (emacs: 0 to 9) If in argument input mode, append
  #            the input digit to the argument being read. Otherwise, call
  #            +ed-insert+. It is an error if the input character is not a
  #            digit or if the existing argument is already greater than a
  #            million.
  # GNU Readline:: +self-insert+ (a, b, A, 1, !, …) Insert yourself.
  #
  # source://reline//lib/reline/line_editor.rb#1498
  def ed_insert(key); end

  # Editline:: +ed-kill-line+ (vi command: +D+, +Ctrl-K+; emacs: +Ctrl-K+,
  #            +Ctrl-U+) + Kill from the cursor to the end of the line.
  # GNU Readline:: +kill-line+ (+C-k+) Kill the text from point to the end of
  #                the line. With a negative numeric argument, kill backward
  #                from the cursor to the beginning of the current line.
  #
  # source://reline//lib/reline/line_editor.rb#1879
  def ed_kill_line(key); end

  # source://reline//lib/reline/line_editor.rb#1572
  def ed_move_to_beg(key); end

  # source://reline//lib/reline/line_editor.rb#1578
  def ed_move_to_end(key); end

  # source://reline//lib/reline/line_editor.rb#1829
  def ed_newline(key); end

  # source://reline//lib/reline/line_editor.rb#1542
  def ed_next_char(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1812
  def ed_next_history(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1555
  def ed_prev_char(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1795
  def ed_prev_history(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1982
  def ed_prev_word(key); end

  # source://reline//lib/reline/line_editor.rb#1526
  def ed_quoted_insert(str, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1758
  def ed_search_next_history(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1743
  def ed_search_prev_history(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2010
  def ed_transpose_chars(key); end

  # source://reline//lib/reline/line_editor.rb#2027
  def ed_transpose_words(key); end

  # do nothing
  #
  # source://reline//lib/reline/line_editor.rb#1477
  def ed_unassigned(key); end

  # source://reline//lib/reline/line_editor.rb#2040
  def em_capitol_case(key); end

  # source://reline//lib/reline/line_editor.rb#1923
  def em_delete(key); end

  # source://reline//lib/reline/line_editor.rb#1990
  def em_delete_next_word(key); end

  # source://reline//lib/reline/line_editor.rb#1938
  def em_delete_or_list(key); end

  # source://reline//lib/reline/line_editor.rb#1858
  def em_delete_prev_char(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2501
  def em_exchange_mark(key); end

  # Editline:: +em-kill-line+ (not bound) Delete the entire contents of the
  #            edit buffer and save it to the cut buffer. +vi-kill-line-prev+
  # GNU Readline:: +kill-whole-line+ (not bound) Kill all characters on the
  #                current line, no matter where point is.
  #
  # source://reline//lib/reline/line_editor.rb#1915
  def em_kill_line(key); end

  # source://reline//lib/reline/line_editor.rb#2076
  def em_kill_region(key); end

  # source://reline//lib/reline/line_editor.rb#2050
  def em_lower_case(key); end

  # source://reline//lib/reline/line_editor.rb#1974
  def em_next_word(key); end

  # source://reline//lib/reline/line_editor.rb#2496
  def em_set_mark(key); end

  # source://reline//lib/reline/line_editor.rb#2063
  def em_upper_case(key); end

  # source://reline//lib/reline/line_editor.rb#1950
  def em_yank(key); end

  # source://reline//lib/reline/line_editor.rb#1956
  def em_yank_pop(key); end

  # source://reline//lib/reline/line_editor.rb#2509
  def emacs_editing_mode(key); end

  # source://reline//lib/reline/line_editor.rb#1578
  def end_of_line(key); end

  # source://reline//lib/reline/line_editor.rb#2501
  def exchange_point_and_mark(key); end

  # source://reline//lib/reline/line_editor.rb#1542
  def forward_char(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1728
  def forward_search_history(key); end

  # source://reline//lib/reline/line_editor.rb#1974
  def forward_word(key); end

  # source://reline//lib/reline/line_editor.rb#1583
  def generate_searcher(search_key); end

  # source://reline//lib/reline/line_editor.rb#183
  def handle_interrupted; end

  # source://reline//lib/reline/line_editor.rb#171
  def handle_resized; end

  # source://reline//lib/reline/line_editor.rb#1743
  def history_search_backward(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1758
  def history_search_forward(key, arg: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://reline//lib/reline/line_editor.rb#956
  def inclusive?(method_obj); end

  # source://reline//lib/reline/line_editor.rb#1667
  def incremental_search_history(key); end

  # source://reline//lib/reline/line_editor.rb#277
  def insert_new_line(cursor_line, next_line); end

  # source://reline//lib/reline/line_editor.rb#1422
  def key_delete(key); end

  # source://reline//lib/reline/line_editor.rb#1430
  def key_newline(key); end

  # Editline:: +ed-kill-line+ (vi command: +D+, +Ctrl-K+; emacs: +Ctrl-K+,
  #            +Ctrl-U+) + Kill from the cursor to the end of the line.
  # GNU Readline:: +kill-line+ (+C-k+) Kill the text from point to the end of
  #                the line. With a negative numeric argument, kill backward
  #                from the cursor to the beginning of the current line.
  #
  # source://reline//lib/reline/line_editor.rb#1879
  def kill_line(key); end

  # Editline:: +em-kill-line+ (not bound) Delete the entire contents of the
  #            edit buffer and save it to the cut buffer. +vi-kill-line-prev+
  # GNU Readline:: +kill-whole-line+ (not bound) Kill all characters on the
  #                current line, no matter where point is.
  #
  # source://reline//lib/reline/line_editor.rb#1915
  def kill_whole_line(key); end

  # source://reline//lib/reline/line_editor.rb#1990
  def kill_word(key); end

  # source://reline//lib/reline/line_editor.rb#794
  def menu(_target, list); end

  # source://reline//lib/reline/line_editor.rb#1463
  def menu_complete(_key); end

  # source://reline//lib/reline/line_editor.rb#1467
  def menu_complete_backward(_key); end

  # source://reline//lib/reline/line_editor.rb#782
  def modify_lines(before, complete); end

  # source://reline//lib/reline/line_editor.rb#901
  def move_completed_list(direction); end

  # source://reline//lib/reline/line_editor.rb#1773
  def move_history(history_pointer, line:, cursor:, save_buffer: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1812
  def next_history(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1054
  def normal_char(key); end

  # source://reline//lib/reline/line_editor.rb#844
  def perform_completion(list, just_show_list); end

  # source://reline//lib/reline/line_editor.rb#2537
  def prev_action_state_value(type); end

  # source://reline//lib/reline/line_editor.rb#1795
  def previous_history(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1195
  def process_auto_indent(line_index = T.unsafe(nil), cursor_dependent: T.unsafe(nil), add_newline: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1479
  def process_insert(force: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#990
  def process_key(key, method_symbol); end

  # source://reline//lib/reline/line_editor.rb#1526
  def quoted_insert(str, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2545
  def re_read_init_file(_key); end

  # source://reline//lib/reline/line_editor.rb#2527
  def redo(_key); end

  # Reflects lines to be rendered and new cursor position to the screen
  # by calculating the difference from the previous render.
  #
  # source://reline//lib/reline/line_editor.rb#508
  def render_differential(new_lines, new_cursor_x, new_cursor_y); end

  # source://reline//lib/reline/line_editor.rb#913
  def retrieve_completion_journey_state; end

  # source://reline//lib/reline/line_editor.rb#1723
  def reverse_search_history(key); end

  # source://reline//lib/reline/line_editor.rb#928
  def run_for_operators(key, method_symbol, &block); end

  # source://reline//lib/reline/line_editor.rb#1733
  def search_history(prefix, pointer_range); end

  # source://reline//lib/reline/line_editor.rb#2397
  def search_next_char(key, arg, need_prev_char: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2449
  def search_prev_char(key, arg, need_next_char = T.unsafe(nil)); end

  # Editline:: +ed-insert+ (vi input: almost all; emacs: printable characters)
  #            In insert mode, insert the input character left of the cursor
  #            position. In replace mode, overwrite the character at the
  #            cursor and move the cursor to the right by one character
  #            position. Accept an argument to do this repeatedly. It is an
  #            error if the input character is the NUL character (+Ctrl-@+).
  #            Failure to enlarge the edit buffer also results in an error.
  # Editline:: +ed-digit+ (emacs: 0 to 9) If in argument input mode, append
  #            the input digit to the argument being read. Otherwise, call
  #            +ed-insert+. It is an error if the input character is not a
  #            digit or if the existing argument is already greater than a
  #            million.
  # GNU Readline:: +self-insert+ (a, b, A, 1, !, …) Insert yourself.
  #
  # source://reline//lib/reline/line_editor.rb#1498
  def self_insert(key); end

  # source://reline//lib/reline/line_editor.rb#2496
  def set_mark(key); end

  # source://reline//lib/reline/line_editor.rb#2541
  def set_next_action_state(type, value); end

  # source://reline//lib/reline/line_editor.rb#300
  def split_by_width(str, max_width, offset: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2010
  def transpose_chars(key); end

  # source://reline//lib/reline/line_editor.rb#2027
  def transpose_words(key); end

  # source://reline//lib/reline/line_editor.rb#2517
  def undo(_key); end

  # Editline:: +vi-kill-line-prev+ (vi: +Ctrl-U+) Delete the string from the
  #            beginning  of the edit buffer to the cursor and save it to the
  #            cut buffer.
  # GNU Readline:: +unix-line-discard+ (+C-u+) Kill backward from the cursor
  #                to the beginning of the current line.
  #
  # source://reline//lib/reline/line_editor.rb#1902
  def unix_line_discard(key); end

  # source://reline//lib/reline/line_editor.rb#2076
  def unix_word_rubout(key); end

  # source://reline//lib/reline/line_editor.rb#2063
  def upcase_word(key); end

  # source://reline//lib/reline/line_editor.rb#698
  def update_each_dialog(dialog, cursor_column, cursor_row, key = T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2096
  def vi_add(key); end

  # source://reline//lib/reline/line_editor.rb#2192
  def vi_add_at_eol(key); end

  # source://reline//lib/reline/line_editor.rb#2211
  def vi_change_meta(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2223
  def vi_change_meta_confirm(byte_pointer_diff); end

  # Editline:: +vi_change_to_eol+ (vi command: +C+) + Kill and change from the cursor to the end of the line.
  #
  # source://reline//lib/reline/line_editor.rb#1891
  def vi_change_to_eol(key); end

  # source://reline//lib/reline/line_editor.rb#2101
  def vi_command_mode(key); end

  # source://reline//lib/reline/line_editor.rb#2229
  def vi_delete_meta(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2240
  def vi_delete_meta_confirm(byte_pointer_diff); end

  # source://reline//lib/reline/line_editor.rb#2173
  def vi_delete_prev_char(key); end

  # source://reline//lib/reline/line_editor.rb#2513
  def vi_editing_mode(key); end

  # source://reline//lib/reline/line_editor.rb#2158
  def vi_end_big_word(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2274
  def vi_end_of_transmission(key); end

  # source://reline//lib/reline/line_editor.rb#2125
  def vi_end_word(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2274
  def vi_eof_maybe(key); end

  # source://reline//lib/reline/line_editor.rb#1568
  def vi_first_print(key); end

  # source://reline//lib/reline/line_editor.rb#2308
  def vi_histedit(key); end

  # source://reline//lib/reline/line_editor.rb#2092
  def vi_insert(key); end

  # source://reline//lib/reline/line_editor.rb#2187
  def vi_insert_at_bol(key); end

  # source://reline//lib/reline/line_editor.rb#2487
  def vi_join_lines(key, arg: T.unsafe(nil)); end

  # Editline:: +vi-kill-line-prev+ (vi: +Ctrl-U+) Delete the string from the
  #            beginning  of the edit buffer to the cursor and save it to the
  #            cut buffer.
  # GNU Readline:: +unix-line-discard+ (+C-u+) Kill backward from the cursor
  #                to the beginning of the current line.
  #
  # source://reline//lib/reline/line_editor.rb#1902
  def vi_kill_line_prev(key); end

  # source://reline//lib/reline/line_editor.rb#2274
  def vi_list_or_eof(key); end

  # source://reline//lib/reline/line_editor.rb#2101
  def vi_movement_mode(key); end

  # source://reline//lib/reline/line_editor.rb#2140
  def vi_next_big_word(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2389
  def vi_next_char(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2107
  def vi_next_word(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2329
  def vi_paste_next(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2320
  def vi_paste_prev(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2149
  def vi_prev_big_word(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2441
  def vi_prev_char(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2116
  def vi_prev_word(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2365
  def vi_replace_char(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#1728
  def vi_search_next(key); end

  # source://reline//lib/reline/line_editor.rb#1723
  def vi_search_prev(key); end

  # source://reline//lib/reline/line_editor.rb#2356
  def vi_to_column(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2301
  def vi_to_history_line(key); end

  # source://reline//lib/reline/line_editor.rb#2393
  def vi_to_next_char(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2445
  def vi_to_prev_char(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2252
  def vi_yank(key, arg: T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#2263
  def vi_yank_confirm(byte_pointer_diff); end

  # source://reline//lib/reline/line_editor.rb#1572
  def vi_zero(key); end

  # source://reline//lib/reline/line_editor.rb#1950
  def yank(key); end

  # source://reline//lib/reline/line_editor.rb#1956
  def yank_pop(key); end
end

# source://reline//lib/reline/line_editor.rb#47
class Reline::LineEditor::CompletionJourneyState < ::Struct
  # Returns the value of attribute line_index
  #
  # @return [Object] the current value of line_index
  def line_index; end

  # Sets the attribute line_index
  #
  # @param value [Object] the value to set the attribute line_index to.
  # @return [Object] the newly set value
  def line_index=(_); end

  # Returns the value of attribute list
  #
  # @return [Object] the current value of list
  def list; end

  # Sets the attribute list
  #
  # @param value [Object] the value to set the attribute list to.
  # @return [Object] the newly set value
  def list=(_); end

  # Returns the value of attribute pointer
  #
  # @return [Object] the current value of pointer
  def pointer; end

  # Sets the attribute pointer
  #
  # @param value [Object] the value to set the attribute pointer to.
  # @return [Object] the newly set value
  def pointer=(_); end

  # Returns the value of attribute post
  #
  # @return [Object] the current value of post
  def post; end

  # Sets the attribute post
  #
  # @param value [Object] the value to set the attribute post to.
  # @return [Object] the newly set value
  def post=(_); end

  # Returns the value of attribute pre
  #
  # @return [Object] the current value of pre
  def pre; end

  # Sets the attribute pre
  #
  # @param value [Object] the value to set the attribute pre to.
  # @return [Object] the newly set value
  def pre=(_); end

  # Returns the value of attribute target
  #
  # @return [Object] the current value of target
  def target; end

  # Sets the attribute target
  #
  # @param value [Object] the value to set the attribute target to.
  # @return [Object] the newly set value
  def target=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://reline//lib/reline/line_editor.rb#39
Reline::LineEditor::CompletionState::COMPLETION = T.let(T.unsafe(nil), Symbol)

# source://reline//lib/reline/line_editor.rb#40
Reline::LineEditor::CompletionState::MENU = T.let(T.unsafe(nil), Symbol)

# source://reline//lib/reline/line_editor.rb#41
Reline::LineEditor::CompletionState::MENU_WITH_PERFECT_MATCH = T.let(T.unsafe(nil), Symbol)

# source://reline//lib/reline/line_editor.rb#38
Reline::LineEditor::CompletionState::NORMAL = T.let(T.unsafe(nil), Symbol)

# source://reline//lib/reline/line_editor.rb#42
Reline::LineEditor::CompletionState::PERFECT_MATCH = T.let(T.unsafe(nil), Symbol)

# source://reline//lib/reline/line_editor.rb#690
Reline::LineEditor::DIALOG_DEFAULT_HEIGHT = T.let(T.unsafe(nil), Integer)

# source://reline//lib/reline/line_editor.rb#636
class Reline::LineEditor::Dialog
  # @return [Dialog] a new instance of Dialog
  #
  # source://reline//lib/reline/line_editor.rb#640
  def initialize(name, config, proc_scope); end

  # source://reline//lib/reline/line_editor.rb#664
  def call(key); end

  # Returns the value of attribute column.
  #
  # source://reline//lib/reline/line_editor.rb#638
  def column; end

  # Sets the attribute column
  #
  # @param value the value to set the attribute column to.
  #
  # source://reline//lib/reline/line_editor.rb#638
  def column=(_arg0); end

  # Returns the value of attribute contents.
  #
  # source://reline//lib/reline/line_editor.rb#637
  def contents; end

  # source://reline//lib/reline/line_editor.rb#657
  def contents=(contents); end

  # Returns the value of attribute name.
  #
  # source://reline//lib/reline/line_editor.rb#637
  def name; end

  # Returns the value of attribute pointer.
  #
  # source://reline//lib/reline/line_editor.rb#638
  def pointer; end

  # Sets the attribute pointer
  #
  # @param value the value to set the attribute pointer to.
  #
  # source://reline//lib/reline/line_editor.rb#638
  def pointer=(_arg0); end

  # Returns the value of attribute scroll_top.
  #
  # source://reline//lib/reline/line_editor.rb#638
  def scroll_top; end

  # Sets the attribute scroll_top
  #
  # @param value the value to set the attribute scroll_top to.
  #
  # source://reline//lib/reline/line_editor.rb#638
  def scroll_top=(_arg0); end

  # source://reline//lib/reline/line_editor.rb#649
  def set_cursor_pos(col, row); end

  # Returns the value of attribute trap_key.
  #
  # source://reline//lib/reline/line_editor.rb#638
  def trap_key; end

  # Sets the attribute trap_key
  #
  # @param value the value to set the attribute trap_key to.
  #
  # source://reline//lib/reline/line_editor.rb#638
  def trap_key=(_arg0); end

  # Returns the value of attribute vertical_offset.
  #
  # source://reline//lib/reline/line_editor.rb#638
  def vertical_offset; end

  # Sets the attribute vertical_offset
  #
  # @param value the value to set the attribute vertical_offset to.
  #
  # source://reline//lib/reline/line_editor.rb#638
  def vertical_offset=(_arg0); end

  # Returns the value of attribute width.
  #
  # source://reline//lib/reline/line_editor.rb#637
  def width; end

  # source://reline//lib/reline/line_editor.rb#653
  def width=(v); end
end

# source://reline//lib/reline/line_editor.rb#558
class Reline::LineEditor::DialogProcScope
  # @return [DialogProcScope] a new instance of DialogProcScope
  #
  # source://reline//lib/reline/line_editor.rb#561
  def initialize(line_editor, config, proc_to_exec, context); end

  # source://reline//lib/reline/line_editor.rb#631
  def call; end

  # source://reline//lib/reline/line_editor.rb#577
  def call_completion_proc_with_checking_args(pre, target, post); end

  # source://reline//lib/reline/line_editor.rb#623
  def completion_journey_data; end

  # source://reline//lib/reline/line_editor.rb#627
  def config; end

  # source://reline//lib/reline/line_editor.rb#569
  def context; end

  # source://reline//lib/reline/line_editor.rb#602
  def cursor_pos; end

  # source://reline//lib/reline/line_editor.rb#585
  def dialog; end

  # source://reline//lib/reline/line_editor.rb#606
  def just_cursor_moving; end

  # source://reline//lib/reline/line_editor.rb#598
  def key; end

  # source://reline//lib/reline/line_editor.rb#618
  def preferred_dialog_height; end

  # source://reline//lib/reline/line_editor.rb#573
  def retrieve_completion_block(set_completion_quote_character = T.unsafe(nil)); end

  # source://reline//lib/reline/line_editor.rb#614
  def screen_height; end

  # source://reline//lib/reline/line_editor.rb#610
  def screen_width; end

  # source://reline//lib/reline/line_editor.rb#589
  def set_cursor_pos(col, row); end

  # source://reline//lib/reline/line_editor.rb#581
  def set_dialog(dialog); end

  # source://reline//lib/reline/line_editor.rb#594
  def set_key(key); end
end

# source://reline//lib/reline/line_editor.rb#559
class Reline::LineEditor::DialogProcScope::CompletionJourneyData < ::Struct
  # Returns the value of attribute list
  #
  # @return [Object] the current value of list
  def list; end

  # Sets the attribute list
  #
  # @param value [Object] the value to set the attribute list to.
  # @return [Object] the newly set value
  def list=(_); end

  # Returns the value of attribute pointer
  #
  # @return [Object] the current value of pointer
  def pointer; end

  # Sets the attribute pointer
  #
  # @param value [Object] the value to set the attribute pointer to.
  # @return [Object] the newly set value
  def pointer=(_); end

  # Returns the value of attribute postposing
  #
  # @return [Object] the current value of postposing
  def postposing; end

  # Sets the attribute postposing
  #
  # @param value [Object] the value to set the attribute postposing to.
  # @return [Object] the newly set value
  def postposing=(_); end

  # Returns the value of attribute preposing
  #
  # @return [Object] the current value of preposing
  def preposing; end

  # Sets the attribute preposing
  #
  # @param value [Object] the value to set the attribute preposing to.
  # @return [Object] the newly set value
  def preposing=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://reline//lib/reline/line_editor.rb#1147
Reline::LineEditor::MAX_INPUT_LINES = T.let(T.unsafe(nil), Integer)

# source://reline//lib/reline/line_editor.rb#73
Reline::LineEditor::MINIMUM_SCROLLBAR_HEIGHT = T.let(T.unsafe(nil), Integer)

# source://reline//lib/reline/line_editor.rb#50
class Reline::LineEditor::MenuInfo
  # @return [MenuInfo] a new instance of MenuInfo
  #
  # source://reline//lib/reline/line_editor.rb#53
  def initialize(list); end

  # source://reline//lib/reline/line_editor.rb#57
  def lines(screen_width); end

  # Returns the value of attribute list.
  #
  # source://reline//lib/reline/line_editor.rb#51
  def list; end
end

# source://reline//lib/reline/line_editor.rb#48
Reline::LineEditor::NullActionState = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline/line_editor.rb#45
class Reline::LineEditor::RenderedScreen < ::Struct
  # Returns the value of attribute base_y
  #
  # @return [Object] the current value of base_y
  def base_y; end

  # Sets the attribute base_y
  #
  # @param value [Object] the value to set the attribute base_y to.
  # @return [Object] the newly set value
  def base_y=(_); end

  # Returns the value of attribute cursor_y
  #
  # @return [Object] the current value of cursor_y
  def cursor_y; end

  # Sets the attribute cursor_y
  #
  # @param value [Object] the value to set the attribute cursor_y to.
  # @return [Object] the newly set value
  def cursor_y=(_); end

  # Returns the value of attribute lines
  #
  # @return [Object] the current value of lines
  def lines; end

  # Sets the attribute lines
  #
  # @param value [Object] the value to set the attribute lines to.
  # @return [Object] the newly set value
  def lines=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://reline//lib/reline/line_editor.rb#18
Reline::LineEditor::VI_MOTIONS = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline/terminfo.rb#17
module Reline::Terminfo
  extend ::Fiddle
  extend ::Fiddle::CParser
  extend ::Fiddle::Importer

  class << self
    # source://reline//lib/reline/terminfo.rb#37
    def curses_dl; end

    # source://reline//lib/reline/terminfo.rb#22
    def curses_dl_files; end

    # NOTE: This means Fiddle and curses are enabled.
    #
    # @return [Boolean]
    #
    # source://reline//lib/reline/terminfo.rb#145
    def enabled?; end

    # source://reline//lib/reline/terminfo.rb#85
    def setupterm(term, fildes); end

    # @return [Boolean]
    #
    # source://reline//lib/reline/terminfo.rb#149
    def term_supported?; end

    # @raise [TerminfoError]
    #
    # source://reline//lib/reline/terminfo.rb#120
    def tigetflag(capname); end

    # @raise [TerminfoError]
    #
    # source://reline//lib/reline/terminfo.rb#132
    def tigetnum(capname); end

    # @raise [TerminfoError]
    #
    # source://reline//lib/reline/terminfo.rb#102
    def tigetstr(capname); end

    # source://reline//lib/reline/terminfo.rb#112
    def tiparm(str, *args); end
  end
end

# source://reline//lib/reline/terminfo.rb#96
class Reline::Terminfo::StringWithTiparm < ::String
  # for method chain
  #
  # source://reline//lib/reline/terminfo.rb#97
  def tiparm(*args); end
end

# source://reline//lib/reline.rb#17
Reline::USERNAME_COMPLETION_PROC = T.let(T.unsafe(nil), T.untyped)

# source://reline//lib/reline/unicode.rb#1
class Reline::Unicode
  class << self
    # source://reline//lib/reline/unicode.rb#82
    def calculate_width(str, allow_escape_code = T.unsafe(nil)); end

    # source://reline//lib/reline/unicode.rb#336
    def ed_transpose_words(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#296
    def em_backward_word(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#316
    def em_big_backward_word(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#247
    def em_forward_word(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#267
    def em_forward_word_with_capitalization(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#44
    def escape_for_print(str); end

    # source://reline//lib/reline/unicode.rb#59
    def get_mbchar_width(mbchar); end

    # source://reline//lib/reline/unicode.rb#233
    def get_next_mbchar_size(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#238
    def get_prev_mbchar_size(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#108
    def split_by_width(str, max_width, encoding = T.unsafe(nil), offset: T.unsafe(nil)); end

    # source://reline//lib/reline/unicode.rb#162
    def take_mbchar_range(str, start_col, width, cover_begin: T.unsafe(nil), cover_end: T.unsafe(nil), padding: T.unsafe(nil)); end

    # Take a chunk of a String cut by width with escape sequences.
    #
    # source://reline//lib/reline/unicode.rb#158
    def take_range(str, start_col, max_width); end

    # source://reline//lib/reline/unicode.rb#625
    def vi_backward_word(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#487
    def vi_big_backward_word(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#457
    def vi_big_forward_end_word(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#437
    def vi_big_forward_word(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#657
    def vi_first_print(line); end

    # source://reline//lib/reline/unicode.rb#548
    def vi_forward_end_word(line, byte_pointer); end

    # source://reline//lib/reline/unicode.rb#507
    def vi_forward_word(line, byte_pointer, drop_terminate_spaces = T.unsafe(nil)); end
  end
end

# source://reline//lib/reline/unicode.rb#40
Reline::Unicode::CSI_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://reline//lib/reline/unicode/east_asian_width.rb#5
Reline::Unicode::EastAsianWidth::CHUNK_LAST = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline/unicode/east_asian_width.rb#5
Reline::Unicode::EastAsianWidth::CHUNK_WIDTH = T.let(T.unsafe(nil), Array)

# C-? C-8
#
# source://reline//lib/reline/unicode.rb#36
Reline::Unicode::EscapedChars = T.let(T.unsafe(nil), Array)

# source://reline//lib/reline/unicode.rb#2
Reline::Unicode::EscapedPairs = T.let(T.unsafe(nil), Hash)

# source://reline//lib/reline/unicode.rb#39
Reline::Unicode::NON_PRINTING_END = T.let(T.unsafe(nil), String)

# source://reline//lib/reline/unicode.rb#38
Reline::Unicode::NON_PRINTING_START = T.let(T.unsafe(nil), String)

# source://reline//lib/reline/unicode.rb#41
Reline::Unicode::OSC_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://reline//lib/reline/unicode.rb#42
Reline::Unicode::WIDTH_SCANNER = T.let(T.unsafe(nil), Regexp)

# source://reline//lib/reline/version.rb#2
Reline::VERSION = T.let(T.unsafe(nil), String)
