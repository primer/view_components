

name: Demo Preview Deploy

on:
  pull_request:

env:
  PR_NUMBER: ${{ github.event.number || github.run_id }}
  COMMIT_REF: ${{ github.event.pull_request.head.sha || github.event.inputs.COMMIT_REF }}
  IMAGE_REPO: "primer/view_components_demo/pr-${{ github.event.number }}"

# This allows one deploy workflow to interrupt another
concurrency:
  group: 'preview-env @ ${{ github.head_ref || github.run_id }} for ${{ github.event.number || github.event.inputs.PR_NUMBER }}'
  cancel-in-progress: true

jobs:
  build:
    if: ${{ github.repository == 'primer/view_components' }}
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@master
    - name: Setup Ruby
      uses: actions/setup-ruby@v1
      with:
        ruby-version: 3.0.x
    - uses: actions/cache@v2
      with:
        path: demo/gemfiles/vendor/bundle
        key: gems-build-kuby-main-ruby-3.0.x-${{ hashFiles('demo/gemfiles/kuby.gemfile.lock') }}
    - name: Docker login
      env:
        AZURE_ACR_PASSWORD: ${{ secrets.AZURE_ACR_PASSWORD }}
      run: echo $AZURE_ACR_PASSWORD | docker login primer.azurecr.io --username GitHubActions --password-stdin
    - name: Bundle
      run: |
        gem install bundler -v '~> 2.3'
        bundle install --jobs 4 --retry 3 --gemfile demo/gemfiles/kuby.gemfile --path vendor/bundle
    - name: 'Set env vars'
      run: |
        # Image tag is unique to each workflow run so that it always triggers a new deployment
        echo "DOCKER_IMAGE=primer.azurecr.io/${{ env.IMAGE_REPO }}:${{ env.COMMIT_REF }}-${{ github.run_number }}-${{ github.run_attempt }}" >> $GITHUB_ENV
    - name: Build
      env:
        RAILS_MASTER_KEY: ${{ secrets.RAILS_MASTER_KEY }}
      run: |
        bin/kuby -e production build --only app -- -t $DOCKER_IMAGE
        bin/kuby -e production build --only assets -- -t $DOCKER_IMAGE
    - name: Push
      run: bin/kuby -e production push
    - name: Run ARM deploy
      # This 'if' will be truth, if this workflow is...
      #  - run as a workflow_dispatch
      #  - run because of a push to main (or when added to a merge queue)
      #  - run as a regular pull request
      # But if it's a pull request, *and* for whatever reason, the pull
      # request has "Auto-merge" enabled, don't bother.
      # The idea is that if auto-merge has been abled, by humans or by
      # bots, they have no intention of viewing the deployed preview anyway.
      # This saves time because the PR can merge sooner.
      if: ${{ !github.event.pull_request.auto_merge }}
      uses: azure/arm-deploy@841b12551939c88af8f6df767c24c38a5620fd0d
      with:
        resourceGroupName: primer
        subscriptionId: 550eb99d-d0c7-4651-a337-f53fa6520c4f
        template: ./.github/workflows/deploy-demo-preview-template.json
        deploymentName: primer-view-components-pr-${{env.PR_NUMBER}}
        parameters: appName="primer-view-components-preview-${{env.PR_NUMBER}}"
          containerImage="primer.azurecr.io/${{ env.IMAGE_REPO }}:latest"
          dockerRegistryUrl="primer.azurecr.io"
          dockerRegistryUsername="primer"
          dockerRegistryPassword="${{ secrets.AZURE_ACR_PASSWORD }}"
